import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope & typeof globalThis;

// Handle Web Share Target POST requests
// MUST be registered BEFORE precacheAndRoute to intercept share requests
self.addEventListener('fetch', (event) => {
  const fetchEvent = event as FetchEvent;
  const url = new URL(fetchEvent.request.url);

  // Intercept /share-receiver POST
  if (fetchEvent.request.method === 'POST' && url.pathname === '/share-receiver') {
    fetchEvent.respondWith(
      (async () => {
        try {
          const formData = await fetchEvent.request.formData();
          const videoFile = formData.get('video') as File;

          if (!videoFile) {
            // No video in share, redirect to home
            return Response.redirect('/?error=no-video', 303);
          }

          // Validate video file type
          if (!videoFile.type.startsWith('video/')) {
            return Response.redirect('/?error=invalid-type', 303);
          }

          // Store video in IndexedDB with timestamp ID
          const videoId = `shared-${Date.now()}`;

          // Dynamic import to keep SW bundle small
          const { storeSharedVideo } = await import('./lib/shareTarget');
          await storeSharedVideo(videoId, videoFile);

          // Redirect to app with video ID in query params
          // Use 303 See Other to prevent POST resubmission on refresh
          return Response.redirect(`/?shared=${videoId}`, 303);
        } catch (error) {
          console.error('[SW] Share receiver error:', error);
          return Response.redirect('/?error=share-failed', 303);
        }
      })()
    );
    return; // Prevent other handlers from processing this request
  }
});

// Precache app shell (generated by Vite PWA)
precacheAndRoute(self.__WB_MANIFEST);

// API calls: Network first, fallback to cache if offline
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/') ||
               url.pathname.startsWith('/process') ||
               url.pathname.startsWith('/get-tags'),
  new NetworkFirst({
    cacheName: 'api-cache',
    networkTimeoutSeconds: 10,
  })
);

// Video downloads: Network first (videos are large, don't cache aggressively)
registerRoute(
  ({ url }) => url.pathname.startsWith('/download/'),
  new NetworkFirst({
    cacheName: 'video-cache',
    networkTimeoutSeconds: 30,
  })
);

// Images: Cache first for performance
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
  })
);

// Fonts: Stale while revalidate
registerRoute(
  ({ request }) => request.destination === 'font',
  new StaleWhileRevalidate({
    cacheName: 'fonts-cache',
  })
);
