---
phase: 03-timeline-editor
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - frontend/src/components/timeline/VideoPlayer.tsx
  - frontend/src/hooks/useVideoSegmentPlayback.ts
  - frontend/src/pages/EditorPage.tsx
autonomous: true

must_haves:
  truths:
    - "Video player plays with custom controls (no native controls)"
    - "User can tap timeline segment to preview in player"
    - "Player stops at segment end during preview"
  artifacts:
    - path: "frontend/src/components/timeline/VideoPlayer.tsx"
      provides: "Custom video player with click-to-play and seekbar"
      min_lines: 80
    - path: "frontend/src/hooks/useVideoSegmentPlayback.ts"
      provides: "Segment playback with timeupdate cleanup"
      min_lines: 30
  key_links:
    - from: "frontend/src/components/timeline/VideoPlayer.tsx"
      to: "useTimelineStore"
      via: "currentTime and isPlaying sync"
      pattern: "setCurrentTime|setPlaying"
    - from: "frontend/src/hooks/useVideoSegmentPlayback.ts"
      to: "HTMLVideoElement"
      via: "timeupdate event listener"
      pattern: "addEventListener.*timeupdate"
---

<objective>
Create the custom video player with segment preview functionality.

Purpose: Users need to preview video segments while editing the timeline. The player must show custom controls (no browser chrome), sync with timeline, and automatically stop at segment boundaries when previewing.

Output: VideoPlayer component with click-to-play/pause, seekbar, time display, and segment playback control via hook.
</objective>

<execution_context>
@C:\Users\OmriS\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\OmriS\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-timeline-editor/03-RESEARCH.md
@.planning/phases/03-timeline-editor/03-01-SUMMARY.md

Key patterns from research:
- Segment playback with timeupdate event cleanup (Pattern 3)
- Native HTML5 video with no library needed
- Store listener reference in useRef for cleanup
- Use >= comparison for segment end (timeupdate fires ~250ms intervals)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useVideoSegmentPlayback hook</name>
  <files>
    frontend/src/hooks/useVideoSegmentPlayback.ts
  </files>
  <action>
Create useVideoSegmentPlayback.ts hook that controls segment playback:

```typescript
import { useEffect, useRef } from 'react';

interface Segment {
  start: number;
  end: number;
}

export function useVideoSegmentPlayback(
  videoRef: React.RefObject<HTMLVideoElement | null>,
  segment: Segment | null,
  isActive: boolean
) {
  const listenerRef = useRef<(() => void) | null>(null);

  useEffect(() => {
    const video = videoRef.current;
    if (!video || !segment || !isActive) return;

    // Seek to segment start
    video.currentTime = segment.start;

    // Auto-play segment
    video.play().catch(err => {
      console.log('Auto-play prevented:', err);
    });

    // Create listener to stop at segment end
    const listener = () => {
      // Use >= because timeupdate fires every ~250ms
      if (video.currentTime >= segment.end - 0.1) {
        video.pause();
        video.currentTime = segment.start; // Loop back to start
      }
    };

    // Store listener for cleanup
    listenerRef.current = listener;
    video.addEventListener('timeupdate', listener);

    // Cleanup on unmount or segment change
    return () => {
      if (listenerRef.current) {
        video.removeEventListener('timeupdate', listenerRef.current);
        listenerRef.current = null;
      }
    };
  }, [videoRef, segment?.start, segment?.end, isActive]);
}
```

Key implementation details:
- Use `segment.end - 0.1` to account for timeupdate interval
- Loop back to segment.start after reaching end
- Cleanup listener on segment change OR component unmount
- `isActive` prop allows parent to enable/disable segment playback mode
  </action>
  <verify>
    - `npm run build` passes
    - Hook exports correctly from hooks folder
  </verify>
  <done>Segment playback hook with proper event listener cleanup</done>
</task>

<task type="auto">
  <name>Task 2: Create VideoPlayer component</name>
  <files>
    frontend/src/components/timeline/VideoPlayer.tsx
  </files>
  <action>
Create VideoPlayer.tsx with custom controls:

```tsx
import { useRef, useEffect, useState } from 'react';
import { Play, Pause } from 'lucide-react';
import { useTimelineStore } from '@/stores/timelineStore';
import { useVideoSegmentPlayback } from '@/hooks/useVideoSegmentPlayback';
import { cn } from '@/lib/utils';
import { formatTime } from '@/hooks/useCanvasTimeline';

export function VideoPlayer() {
  const videoRef = useRef<HTMLVideoElement>(null);
  const [showIcon, setShowIcon] = useState(false);

  const {
    videoUrl,
    videoDuration,
    currentTime,
    isPlaying,
    selectedSegmentIndex,
    segments,
    setCurrentTime,
    setPlaying,
  } = useTimelineStore();

  // Get selected segment for preview
  const selectedSegment = selectedSegmentIndex !== null
    ? segments[selectedSegmentIndex]
    : null;

  // Use segment playback hook when segment is selected
  useVideoSegmentPlayback(videoRef, selectedSegment, selectedSegmentIndex !== null);

  // Sync currentTime with store (when not in segment preview mode)
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const handleTimeUpdate = () => {
      // Only update store if not in segment preview mode
      if (selectedSegmentIndex === null) {
        setCurrentTime(video.currentTime);
      }
    };

    const handlePlay = () => setPlaying(true);
    const handlePause = () => setPlaying(false);
    const handleLoadedMetadata = () => {
      // Duration is set by store.loadVideo, but sync if different
    };

    video.addEventListener('timeupdate', handleTimeUpdate);
    video.addEventListener('play', handlePlay);
    video.addEventListener('pause', handlePause);
    video.addEventListener('loadedmetadata', handleLoadedMetadata);

    return () => {
      video.removeEventListener('timeupdate', handleTimeUpdate);
      video.removeEventListener('play', handlePlay);
      video.removeEventListener('pause', handlePause);
      video.removeEventListener('loadedmetadata', handleLoadedMetadata);
    };
  }, [setCurrentTime, setPlaying, selectedSegmentIndex]);

  const togglePlayPause = () => {
    const video = videoRef.current;
    if (!video) return;

    if (isPlaying) {
      video.pause();
    } else {
      video.play();
    }

    // Show icon animation
    setShowIcon(true);
    setTimeout(() => setShowIcon(false), 800);
  };

  const handleSeek = (e: React.ChangeEvent<HTMLInputElement>) => {
    const video = videoRef.current;
    if (!video || videoDuration === 0) return;

    const newTime = (parseFloat(e.target.value) / 100) * videoDuration;
    video.currentTime = newTime;
    setCurrentTime(newTime);
  };

  if (!videoUrl) {
    return (
      <div className="bg-black rounded-xl aspect-video flex items-center justify-center">
        <span className="text-gray-500">לא נטען וידאו</span>
      </div>
    );
  }

  return (
    <div className="bg-black rounded-xl overflow-hidden">
      {/* Video */}
      <div
        className="relative aspect-video bg-black cursor-pointer"
        onClick={togglePlayPause}
      >
        <video
          ref={videoRef}
          src={videoUrl}
          className="w-full h-full object-contain"
          playsInline
        />

        {/* Play/Pause Icon Overlay */}
        <div
          className={cn(
            "absolute inset-0 flex items-center justify-center pointer-events-none transition-opacity duration-300",
            showIcon ? "opacity-100" : "opacity-0"
          )}
        >
          <div className="bg-black/60 rounded-full w-20 h-20 flex items-center justify-center">
            {isPlaying ? (
              <Pause className="w-10 h-10 text-white" />
            ) : (
              <Play className="w-10 h-10 text-white ml-1" />
            )}
          </div>
        </div>

        {/* Segment preview indicator */}
        {selectedSegmentIndex !== null && (
          <div className="absolute top-2 right-2 bg-orange-500 text-white text-xs px-2 py-1 rounded">
            תצוגה מקדימה: סגמנט #{selectedSegmentIndex + 1}
          </div>
        )}
      </div>

      {/* Controls */}
      <div className="bg-gradient-to-b from-black/70 to-black/90 p-3 flex items-center gap-3">
        <div className="text-white text-sm font-medium min-w-[90px] text-center">
          {formatTime(currentTime)} / {formatTime(videoDuration)}
        </div>

        <input
          type="range"
          min="0"
          max="100"
          step="0.1"
          value={videoDuration > 0 ? (currentTime / videoDuration) * 100 : 0}
          onChange={handleSeek}
          dir="ltr"
          className="flex-1 h-2 bg-white/30 rounded-full appearance-none cursor-pointer
                     [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-4
                     [&::-webkit-slider-thumb]:h-4 [&::-webkit-slider-thumb]:rounded-full
                     [&::-webkit-slider-thumb]:bg-blue-500 [&::-webkit-slider-thumb]:cursor-pointer"
        />
      </div>
    </div>
  );
}
```

Key implementation details:
- No native controls (`controls` prop omitted)
- Click anywhere on video to toggle play/pause
- Play/Pause icon shows briefly (800ms) after click
- Seekbar is LTR direction even in RTL layout
- When segment is selected, shows preview indicator badge
- playsInline for iOS compatibility
  </action>
  <verify>
    - `npm run build` passes
    - VideoPlayer renders video from store videoUrl
    - Click toggles play/pause
    - Seekbar updates currentTime
  </verify>
  <done>Custom video player with click-to-play and seekbar controls</done>
</task>

<task type="auto">
  <name>Task 3: Wire VideoPlayer and segment preview to EditorPage</name>
  <files>
    frontend/src/pages/EditorPage.tsx
    frontend/src/components/timeline/TimelineCanvas.tsx
  </files>
  <action>
1. Update EditorPage.tsx to include VideoPlayer:

Replace the video placeholder with:
```tsx
import { VideoPlayer } from '@/components/timeline/VideoPlayer';

// In render:
<VideoPlayer />
```

2. Update TimelineCanvas.tsx to handle segment clicks:

Add onClick handler that:
- Calculates which segment was clicked based on X position
- Calls `selectSegment(index)` from store

```typescript
const handleCanvasClick = (e: React.MouseEvent<HTMLCanvasElement>) => {
  const canvas = canvasRef.current;
  if (!canvas || videoDuration === 0) return;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const clickedTime = (x / rect.width) * videoDuration;

  // Check if click is on a cut point (within 10px) - don't select segment
  const clickedCutPoint = cutPoints.find(cp => {
    const cpX = (cp.time / videoDuration) * rect.width;
    return Math.abs(x - cpX) < 10;
  });

  if (clickedCutPoint) {
    selectCutPoint(clickedCutPoint.id);
    return;
  }

  // Find which segment was clicked
  const segmentIndex = segments.findIndex(seg =>
    clickedTime >= seg.start && clickedTime < seg.end
  );

  if (segmentIndex !== -1) {
    selectSegment(segmentIndex);
  }
};
```

3. Update segment cards in EditorPage to be clickable:

```tsx
{segments.map((seg, i) => (
  <div
    key={i}
    onClick={() => selectSegment(i)}
    className={cn(
      "bg-gray-800 rounded-lg p-3 text-right cursor-pointer transition-colors",
      selectedSegmentIndex === i && "ring-2 ring-orange-500 bg-gray-700"
    )}
  >
    <div className="flex items-center justify-between">
      <span className="font-medium">סגמנט #{i + 1}</span>
      {seg.details && (
        <span className="text-green-500 text-sm">&#x2713;</span>
      )}
    </div>
    <span className="text-gray-400 text-sm">
      {formatTime(seg.start)} - {formatTime(seg.end)}
      <span className="mr-2">({formatTime(seg.end - seg.start)})</span>
    </span>
  </div>
))}
```

4. Add deselect on click outside:
- Clicking video player area (not during segment preview) clears selection
- Add a "סגור תצוגה מקדימה" button when segment is selected
  </action>
  <verify>
    - `npm run build` passes
    - Video plays when clicked
    - Clicking a segment card highlights it and starts preview
    - Video loops within segment boundaries
    - Clicking different segment switches preview
  </verify>
  <done>VideoPlayer integrated with segment preview functionality</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build verification:
   ```bash
   cd frontend && npm run build
   ```
   Expected: Build succeeds with no errors

2. Video playback verification:
   - Upload a video and navigate to editor
   - Video should display and be playable
   - Click video to toggle play/pause (icon animation shows)
   - Seekbar should update as video plays
   - Seekbar drag should seek video

3. Segment preview verification:
   - Click a segment card
   - Video should seek to segment start and play
   - Video should stop and loop at segment end
   - Orange badge shows "preview: segment #N"
   - Click different segment switches preview
   - Click outside to deselect
</verification>

<success_criteria>
- Video player has no native browser controls
- Click-to-play/pause works with icon animation
- Seekbar shows progress and allows seeking
- Time display shows current/total in MM:SS format
- Clicking segment card activates segment preview
- Segment preview loops within segment boundaries
- Selected segment card has orange ring highlight
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-timeline-editor/03-02-SUMMARY.md`
</output>
