---
phase: 03-timeline-editor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/stores/timelineStore.ts
  - frontend/src/hooks/useCanvasTimeline.ts
  - frontend/src/components/timeline/TimelineCanvas.tsx
  - frontend/src/pages/EditorPage.tsx
autonomous: true

must_haves:
  truths:
    - "Canvas timeline renders cut points from scene detection"
    - "User can drag cut points to adjust timing with live feedback"
    - "User can add manual cut points at current playhead position"
    - "User can zoom timeline with +/- buttons for precision editing"
  artifacts:
    - path: "frontend/src/stores/timelineStore.ts"
      provides: "Timeline state management with cut points and segments"
      exports: ["useTimelineStore"]
    - path: "frontend/src/hooks/useCanvasTimeline.ts"
      provides: "Canvas rendering logic with DPR scaling"
      min_lines: 100
    - path: "frontend/src/components/timeline/TimelineCanvas.tsx"
      provides: "Canvas timeline with drag overlay and touch support"
      min_lines: 150
  key_links:
    - from: "frontend/src/pages/EditorPage.tsx"
      to: "useTimelineStore"
      via: "URL params parsing into loadVideo"
      pattern: "loadVideo\\(.*url.*cuts"
    - from: "frontend/src/components/timeline/TimelineCanvas.tsx"
      to: "@dnd-kit/core"
      via: "DndContext with sensors"
      pattern: "DndContext.*sensors"
---

<objective>
Create the Canvas timeline component with cut point rendering, dragging, and manual cut point addition.

Purpose: This is the core timeline editing functionality - users need to see and manipulate cut points on a visual timeline to edit their workout video segments.

Output: TimelineCanvas component with draggable cut points, timelineStore for state management, and EditorPage wired to receive video from upload flow.
</objective>

<execution_context>
@C:\Users\OmriS\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\OmriS\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-timeline-editor/03-RESEARCH.md
@.planning/phases/02-upload-feature/02-01-SUMMARY.md

Key patterns from research:
- Custom Canvas with useRef + useEffect for rendering (Pattern 1)
- dnd-kit overlay on canvas for drag interactions (Pattern 2)
- Zustand store for timeline state (Pattern 6)
- devicePixelRatio scaling for sharp rendering on retina
- Touch and mouse sensor configuration from dnd-kit
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dnd-kit and create timelineStore</name>
  <files>
    frontend/package.json
    frontend/src/stores/timelineStore.ts
  </files>
  <action>
1. Install dnd-kit packages:
   ```bash
   cd frontend && npm install @dnd-kit/core @dnd-kit/utilities
   ```

2. Create timelineStore.ts with Zustand following existing pattern from uploadStore.ts:

State interface:
```typescript
interface CutPoint {
  time: number;
  type: 'auto' | 'manual';
  id: string;
}

interface SegmentDetails {
  name: string;
  muscleGroups: string[];
  equipment: string[];
  removeAudio: boolean;
}

interface Segment {
  start: number;
  end: number;
  details: SegmentDetails | null;
}

interface TimelineState {
  // Video
  videoUrl: string | null;
  videoDuration: number;

  // Timeline
  cutPoints: CutPoint[];
  segments: Segment[];
  selectedSegmentIndex: number | null;
  selectedCutPointId: string | null;
  zoomLevel: number; // 0.5 to 3.0, default 1.0

  // Playback
  currentTime: number;
  isPlaying: boolean;

  // Existing tags for autocomplete
  existingTags: {
    muscleGroups: string[];
    equipment: string[];
  };

  // Actions
  loadVideo: (url: string, duration: number, suggestedCuts: number[]) => void;
  addCutPoint: (time: number) => void;
  updateCutPoint: (id: string, newTime: number) => void;
  deleteCutPoint: (id: string) => void;
  selectCutPoint: (id: string | null) => void;
  selectSegment: (index: number | null) => void;
  updateSegmentDetails: (index: number, details: SegmentDetails) => void;
  setCurrentTime: (time: number) => void;
  setPlaying: (playing: boolean) => void;
  setZoomLevel: (level: number) => void;
  loadExistingTags: (tags: { muscleGroups: string[]; equipment: string[] }) => void;
  reset: () => void;
}
```

Include helper function `getSegmentsFromCutPoints(cutPoints, duration)` that:
- Returns single segment [0, duration] if no cut points
- Creates segments between cut points
- Preserves existing segment details when regenerating (match by approximate time)

IMPORTANT: When regenerating segments after cut point changes, preserve the `details` property for segments that overlap with previous segments (within 1 second tolerance).
  </action>
  <verify>
    - `npm run build` passes with no TypeScript errors
    - timelineStore exports useTimelineStore hook
    - All actions are implemented
  </verify>
  <done>Zustand timeline store with complete state management for cut points and segments</done>
</task>

<task type="auto">
  <name>Task 2a: Create useCanvasTimeline hook</name>
  <files>
    frontend/src/hooks/useCanvasTimeline.ts
  </files>
  <action>
Create useCanvasTimeline.ts hook for canvas rendering:

```typescript
// Handles:
// - devicePixelRatio scaling for retina displays
// - Resize observer for responsive canvas
// - Drawing functions: timeMarkers, segments, cutPoints, playhead
// - Zoom level parameter for scaling visible time range
```

Drawing implementation from existing vanilla JS (static/js/timeline-editor.js):
- Background: #f8f9ff (light mode compatible with dark theme container)
- Time markers: every 5 seconds (adjust interval based on zoom), #e0e0e0 stroke, #999 text
- Segments: white fill with green border if has details, orange if selected
- Cut points: blue (#667eea) for auto, green (#48bb78) for manual
- Cut point circles: 8px radius with white stroke
- Playhead: red (#fc8181) dashed line with triangle at top

Hook interface:
```typescript
interface UseCanvasTimelineOptions {
  duration: number;
  cutPoints: CutPoint[];
  segments: Segment[];
  currentTime: number;
  selectedSegmentIndex: number | null;
  zoomLevel: number; // 0.5 to 3.0
  scrollOffset: number; // For panning when zoomed
}

export function useCanvasTimeline(
  canvasRef: RefObject<HTMLCanvasElement>,
  wrapperRef: RefObject<HTMLDivElement>,
  options: UseCanvasTimelineOptions
): {
  getTimeFromX: (x: number) => number;
  getXFromTime: (time: number) => number;
  redraw: () => void;
}
```

Export formatTime(seconds) helper function for reuse.
  </action>
  <verify>
    - `npm run build` passes
    - Hook exports useCanvasTimeline and formatTime
  </verify>
  <done>Canvas rendering hook with high-DPI support and zoom awareness</done>
</task>

<task type="auto">
  <name>Task 2b: Create TimelineCanvas component with dnd-kit</name>
  <files>
    frontend/src/components/timeline/TimelineCanvas.tsx
  </files>
  <action>
Create TimelineCanvas.tsx component with dnd-kit:

Structure:
```tsx
<DndContext sensors={sensors} onDragEnd={handleDragEnd} onDragMove={handleDragMove}>
  <div ref={wrapperRef} className="relative">
    {/* Zoom controls */}
    <div className="absolute top-2 left-2 flex gap-1 z-10">
      <button onClick={() => setZoom(z => Math.min(3, z + 0.5))} className="...">+</button>
      <span className="...">{zoomLevel}x</span>
      <button onClick={() => setZoom(z => Math.max(0.5, z - 0.5))} className="...">-</button>
    </div>

    {/* Canvas for rendering */}
    <canvas ref={canvasRef} className="block w-full h-[150px] touch-none" />

    {/* Draggable overlays positioned over cut points */}
    {cutPoints.map(cp => (
      <DraggableCutPoint key={cp.id} id={cp.id} x={getXFromTime(cp.time)} />
    ))}

    {/* Time display during drag */}
    {draggingId && <TimeOverlay time={...} x={...} />}
  </div>
</DndContext>
```

Sensors configuration:
```typescript
const sensors = useSensors(
  useSensor(MouseSensor, { activationConstraint: { distance: 5 } }),
  useSensor(TouchSensor, { activationConstraint: { delay: 100, tolerance: 5 } })
);
```

DraggableCutPoint subcomponent:
- Uses useDraggable from @dnd-kit/core
- Renders invisible 44x44px touch target positioned at cut point X
- Shows visible circle (16px) matching canvas cut point style

Handle timeline clicks:
- Click on empty area: seek video to clicked time
- Click on segment: select segment (open drawer in Plan 03)

Zoom state:
- Store zoomLevel in timelineStore (add to Task 1)
- Range: 0.5x to 3.0x (default 1.0x)
- +/- buttons with 0.5 step
- Display current zoom level between buttons
  </action>
  <verify>
    - `npm run build` passes
    - TimelineCanvas renders without errors when given mock data
    - Cut points are draggable (will test visually in Task 3)
    - Zoom buttons adjust zoom level
  </verify>
  <done>Canvas timeline component with draggable cut point overlays and zoom controls</done>
</task>

<task type="auto">
  <name>Task 3: Wire EditorPage with URL params and timeline</name>
  <files>
    frontend/src/pages/EditorPage.tsx
    frontend/src/lib/api.ts
  </files>
  <action>
1. Add getTags API function to api.ts:
```typescript
export async function getTags(): Promise<{ muscle_groups: string[]; equipment: string[] }> {
  const response = await fetch('/get-tags');
  if (!response.ok) throw new Error('Failed to fetch tags');
  return response.json();
}
```

2. Update EditorPage.tsx to:

a) Parse URL query params on mount:
```typescript
const [searchParams] = useSearchParams();
const videoUrl = searchParams.get('video');
const cutsParam = searchParams.get('cuts');
```

b) Load video metadata and initialize store:
```typescript
useEffect(() => {
  if (!videoUrl) return;

  // Create video element to get duration
  const video = document.createElement('video');
  video.src = videoUrl;
  video.onloadedmetadata = () => {
    const suggestedCuts = cutsParam
      ? cutsParam.split(',').map(s => parseFloat(s)).filter(n => !isNaN(n))
      : [];
    loadVideo(videoUrl, video.duration, suggestedCuts);
  };
}, [videoUrl, cutsParam]);
```

c) Load existing tags on mount:
```typescript
useEffect(() => {
  getTags().then(tags => {
    loadExistingTags({
      muscleGroups: tags.muscle_groups,
      equipment: tags.equipment
    });
  }).catch(console.error);
}, []);
```

d) Render layout (Hebrew RTL):
```tsx
<div className="flex flex-col gap-4 p-4" dir="rtl">
  {/* Header */}
  <div className="flex items-center justify-between">
    <h1 className="text-xl font-bold">עורך טיימליין</h1>
    <div className="flex gap-2">
      <Button onClick={handleAddCutPoint} variant="secondary" size="sm">
        <Scissors className="w-4 h-4 ml-1" />
        הוסף חיתוך
      </Button>
    </div>
  </div>

  {/* Video placeholder - Plan 02 */}
  <div className="bg-black rounded-xl aspect-video flex items-center justify-center">
    <span className="text-gray-500">Video Player (Plan 02)</span>
  </div>

  {/* Timeline */}
  <TimelineCanvas />

  {/* Segment cards placeholder - Plan 03 */}
  <div className="space-y-2">
    {segments.map((seg, i) => (
      <div key={i} className="bg-gray-800 rounded-lg p-3 text-right">
        <span>סגמנט #{i + 1}</span>
        <span className="text-gray-400 text-sm mr-2">
          {formatTime(seg.start)} - {formatTime(seg.end)}
        </span>
      </div>
    ))}
  </div>
</div>
```

e) Add cut point handler:
```typescript
const handleAddCutPoint = () => {
  if (currentTime > 0 && currentTime < videoDuration) {
    addCutPoint(currentTime);
  }
};
```
  </action>
  <verify>
    - `npm run build` passes
    - Navigate to /editor?video=/download/test/test.mp4&cuts=5,10,15 shows timeline
    - Timeline renders with 3 cut points at specified times
    - "Add Cut" button adds a cut point at currentTime (0 by default)
  </verify>
  <done>EditorPage receives video from upload flow and renders timeline with cut points</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build verification:
   ```bash
   cd frontend && npm run build
   ```
   Expected: Build succeeds with no errors

2. Runtime verification:
   - Start dev server: `npm run dev`
   - Upload a video on the Upload page
   - After processing, should redirect to /editor with video URL and cuts
   - Timeline canvas should render with cut points
   - Cut points should be draggable with touch and mouse
   - Add Cut button should add green manual cut point

3. State verification:
   - Open React DevTools
   - Verify timelineStore has correct videoUrl, cutPoints, segments
   - Drag a cut point and verify cutPoints array updates
   - Verify segments recalculate after cut point change
</verification>

<success_criteria>
- Canvas timeline renders cut points from scene detection (auto=blue, manual=green)
- User can drag cut points with mouse and touch (5px/100ms activation)
- Dragging shows live time overlay feedback
- User can add manual cut points at playhead position
- User can zoom timeline with +/- buttons (0.5x to 3.0x range)
- Segments list updates when cut points change
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-timeline-editor/03-01-SUMMARY.md`
</output>
