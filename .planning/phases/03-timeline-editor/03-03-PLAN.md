---
phase: 03-timeline-editor
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - frontend/src/components/ui/drawer.tsx
  - frontend/src/components/tagging/SegmentDrawer.tsx
  - frontend/src/components/tagging/AutocompleteChips.tsx
  - frontend/src/pages/EditorPage.tsx
autonomous: true

must_haves:
  truths:
    - "User can tap segment to open tagging drawer"
    - "Drawer shows video preview of selected segment"
    - "User can enter exercise name, select muscle groups/equipment, toggle audio removal"
    - "Segment card shows checkmark when details saved"
  artifacts:
    - path: "frontend/src/components/ui/drawer.tsx"
      provides: "shadcn/ui Drawer component"
      min_lines: 50
    - path: "frontend/src/components/tagging/SegmentDrawer.tsx"
      provides: "Bottom sheet with form and video preview"
      min_lines: 150
    - path: "frontend/src/components/tagging/AutocompleteChips.tsx"
      provides: "Tag input with autocomplete and chips"
      min_lines: 60
  key_links:
    - from: "frontend/src/components/tagging/SegmentDrawer.tsx"
      to: "useTimelineStore"
      via: "updateSegmentDetails action"
      pattern: "updateSegmentDetails"
    - from: "frontend/src/components/tagging/SegmentDrawer.tsx"
      to: "drawer.tsx"
      via: "Drawer component import"
      pattern: "import.*Drawer.*from"
---

<objective>
Create the segment tagging drawer with exercise form and autocomplete.

Purpose: After identifying segments in the timeline, users need to tag each segment with exercise name, muscle groups, and equipment. The drawer provides a mobile-friendly form with video preview.

Output: SegmentDrawer component with video preview, exercise name input, autocomplete chips for tags, and audio removal toggle.
</objective>

<execution_context>
@C:\Users\OmriS\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\OmriS\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-timeline-editor/03-RESEARCH.md
@.planning/phases/03-timeline-editor/03-01-SUMMARY.md
@.planning/phases/03-timeline-editor/03-02-SUMMARY.md

Key patterns from research:
- shadcn/ui Drawer for mobile bottom sheet (Pattern 4)
- Material UI Autocomplete with chips (Pattern 5) - BUT we'll use simpler custom implementation
- Media Fragments URI (#t=start,end) for drawer preview video

Note: Research suggested MUI Autocomplete, but to avoid heavy dependency and theme conflicts, we'll build a simpler custom autocomplete component.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install shadcn/ui Drawer component</name>
  <files>
    frontend/package.json
    frontend/src/components/ui/drawer.tsx
    frontend/components.json
  </files>
  <action>
1. Initialize shadcn/ui if not already done:
   ```bash
   cd frontend
   npx shadcn@latest init -y
   ```

   When prompted, use these settings:
   - Style: Default
   - Base color: Slate
   - CSS variables: Yes

2. Add the Drawer component:
   ```bash
   npx shadcn@latest add drawer
   ```

This will create `frontend/src/components/ui/drawer.tsx` with:
- Drawer, DrawerPortal, DrawerOverlay
- DrawerTrigger, DrawerClose
- DrawerContent, DrawerHeader, DrawerFooter
- DrawerTitle, DrawerDescription

The drawer is built on Vaul which handles:
- Swipe-to-dismiss gestures
- Slide animations
- Accessibility (focus trap, aria labels)
- iOS safe area handling

3. Verify drawer works with Tailwind dark mode:
   - DrawerContent should use `bg-gray-900` or similar
   - May need to override default light styles
  </action>
  <verify>
    - `npm run build` passes
    - drawer.tsx exists with all exports
    - No TypeScript errors in drawer.tsx
  </verify>
  <done>shadcn/ui Drawer component installed and configured</done>
</task>

<task type="auto">
  <name>Task 2: Create AutocompleteChips component</name>
  <files>
    frontend/src/components/tagging/AutocompleteChips.tsx
  </files>
  <action>
Create a custom AutocompleteChips component (lighter than MUI):

```tsx
import { useState, useRef, useEffect } from 'react';
import { X } from 'lucide-react';
import { cn } from '@/lib/utils';

interface AutocompleteChipsProps {
  label: string;
  placeholder: string;
  options: string[];
  value: string[];
  onChange: (value: string[]) => void;
}

export function AutocompleteChips({
  label,
  placeholder,
  options,
  value,
  onChange,
}: AutocompleteChipsProps) {
  const [inputValue, setInputValue] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const [highlightedIndex, setHighlightedIndex] = useState(-1);
  const inputRef = useRef<HTMLInputElement>(null);
  const listRef = useRef<HTMLUListElement>(null);

  // Filter options based on input and exclude already selected
  const filteredOptions = options.filter(
    opt =>
      opt.toLowerCase().includes(inputValue.toLowerCase()) &&
      !value.includes(opt)
  );

  const addChip = (chip: string) => {
    const trimmed = chip.trim();
    if (trimmed && !value.includes(trimmed)) {
      onChange([...value, trimmed]);
    }
    setInputValue('');
    setIsOpen(false);
    setHighlightedIndex(-1);
  };

  const removeChip = (chip: string) => {
    onChange(value.filter(v => v !== chip));
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      if (highlightedIndex >= 0 && filteredOptions[highlightedIndex]) {
        addChip(filteredOptions[highlightedIndex]);
      } else if (inputValue.trim()) {
        addChip(inputValue);
      }
    } else if (e.key === 'ArrowDown') {
      e.preventDefault();
      setHighlightedIndex(prev =>
        prev < filteredOptions.length - 1 ? prev + 1 : prev
      );
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      setHighlightedIndex(prev => (prev > 0 ? prev - 1 : -1));
    } else if (e.key === 'Escape') {
      setIsOpen(false);
      setHighlightedIndex(-1);
    } else if (e.key === 'Backspace' && !inputValue && value.length > 0) {
      removeChip(value[value.length - 1]);
    }
  };

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (inputRef.current && !inputRef.current.contains(e.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  return (
    <div className="space-y-2">
      <label className="block text-sm font-medium text-gray-300">{label}</label>

      {/* Chips */}
      <div className="flex flex-wrap gap-2 mb-2">
        {value.map(chip => (
          <span
            key={chip}
            className="inline-flex items-center gap-1 bg-blue-600 text-white px-2 py-1 rounded-full text-sm"
          >
            {chip}
            <button
              type="button"
              onClick={() => removeChip(chip)}
              className="hover:bg-blue-700 rounded-full p-0.5"
            >
              <X className="w-3 h-3" />
            </button>
          </span>
        ))}
      </div>

      {/* Input with dropdown */}
      <div className="relative">
        <input
          ref={inputRef}
          type="text"
          value={inputValue}
          onChange={e => {
            setInputValue(e.target.value);
            setIsOpen(true);
            setHighlightedIndex(-1);
          }}
          onFocus={() => setIsOpen(true)}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          className="w-full bg-gray-800 border border-gray-700 rounded-lg px-3 py-2 text-white
                     placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
        />

        {/* Dropdown */}
        {isOpen && filteredOptions.length > 0 && (
          <ul
            ref={listRef}
            className="absolute z-50 w-full mt-1 bg-gray-800 border border-gray-700 rounded-lg
                       shadow-lg max-h-40 overflow-y-auto"
          >
            {filteredOptions.map((option, index) => (
              <li
                key={option}
                onClick={() => addChip(option)}
                className={cn(
                  "px-3 py-2 cursor-pointer text-white",
                  index === highlightedIndex && "bg-gray-700",
                  index !== highlightedIndex && "hover:bg-gray-700"
                )}
              >
                {option}
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}
```

Key features:
- Chips display with X button to remove
- Dropdown filters as user types
- Keyboard navigation (arrows, enter, escape, backspace)
- Allows new values not in options (freeSolo)
- RTL compatible (text flows naturally)
  </action>
  <verify>
    - `npm run build` passes
    - Component handles adding/removing chips
    - Dropdown shows filtered options
  </verify>
  <done>Custom autocomplete component with chips and keyboard navigation</done>
</task>

<task type="auto">
  <name>Task 3: Create SegmentDrawer component</name>
  <files>
    frontend/src/components/tagging/SegmentDrawer.tsx
    frontend/src/pages/EditorPage.tsx
  </files>
  <action>
1. Create SegmentDrawer.tsx:

```tsx
import { useState, useEffect } from 'react';
import { X, Volume2, VolumeX } from 'lucide-react';
import {
  Drawer,
  DrawerContent,
  DrawerHeader,
  DrawerTitle,
  DrawerClose,
} from '@/components/ui/drawer';
import { AutocompleteChips } from './AutocompleteChips';
import { Button } from '@/components/ui/Button';
import { useTimelineStore } from '@/stores/timelineStore';
import { formatTime } from '@/hooks/useCanvasTimeline';

export function SegmentDrawer() {
  const {
    videoUrl,
    segments,
    selectedSegmentIndex,
    existingTags,
    selectSegment,
    updateSegmentDetails,
  } = useTimelineStore();

  const segment = selectedSegmentIndex !== null ? segments[selectedSegmentIndex] : null;
  const isOpen = selectedSegmentIndex !== null;

  // Local form state
  const [name, setName] = useState('');
  const [muscleGroups, setMuscleGroups] = useState<string[]>([]);
  const [equipment, setEquipment] = useState<string[]>([]);
  const [removeAudio, setRemoveAudio] = useState(false);

  // Load existing details when segment changes
  useEffect(() => {
    if (segment?.details) {
      setName(segment.details.name);
      setMuscleGroups(segment.details.muscleGroups);
      setEquipment(segment.details.equipment);
      setRemoveAudio(segment.details.removeAudio);
    } else {
      setName('');
      setMuscleGroups([]);
      setEquipment([]);
      setRemoveAudio(false);
    }
  }, [segment]);

  const handleClose = () => {
    selectSegment(null);
  };

  const handleSave = () => {
    if (selectedSegmentIndex === null) return;

    if (!name.trim()) {
      alert('אנא הזן שם תרגיל');
      return;
    }

    updateSegmentDetails(selectedSegmentIndex, {
      name: name.trim(),
      muscleGroups,
      equipment,
      removeAudio,
    });

    handleClose();
  };

  const handleDelete = () => {
    if (selectedSegmentIndex === null) return;

    if (confirm('האם למחוק את פרטי הסגמנט?')) {
      updateSegmentDetails(selectedSegmentIndex, null as any);
      handleClose();
    }
  };

  // Video preview URL with Media Fragments
  const previewUrl = segment && videoUrl
    ? `${videoUrl}#t=${segment.start},${segment.end}`
    : '';

  return (
    <Drawer open={isOpen} onOpenChange={open => !open && handleClose()}>
      <DrawerContent className="bg-gray-900 border-gray-800 max-h-[90vh]">
        <DrawerHeader className="border-b border-gray-800 pb-3">
          <div className="flex items-center justify-between">
            <DrawerTitle className="text-white">
              פרטי סגמנט #{selectedSegmentIndex !== null ? selectedSegmentIndex + 1 : ''}
            </DrawerTitle>
            <DrawerClose asChild>
              <button className="rounded-full p-2 hover:bg-gray-800 text-gray-400">
                <X className="w-5 h-5" />
              </button>
            </DrawerClose>
          </div>
          {segment && (
            <p className="text-sm text-gray-400 mt-1">
              {formatTime(segment.start)} - {formatTime(segment.end)}
              <span className="mr-2">
                (משך: {formatTime(segment.end - segment.start)})
              </span>
            </p>
          )}
        </DrawerHeader>

        <div className="overflow-y-auto p-4 space-y-4">
          {/* Video Preview */}
          {previewUrl && (
            <div className="rounded-lg overflow-hidden bg-black">
              <video
                key={previewUrl} // Force reload when segment changes
                src={previewUrl}
                className="w-full aspect-video object-contain"
                controls
                playsInline
                autoPlay
                muted
              />
            </div>
          )}

          {/* Exercise Name */}
          <div className="space-y-2">
            <label className="block text-sm font-medium text-gray-300">
              שם התרגיל *
            </label>
            <input
              type="text"
              value={name}
              onChange={e => setName(e.target.value)}
              placeholder="לדוגמה: סקוואט, שכיבות סמיכה..."
              className="w-full bg-gray-800 border border-gray-700 rounded-lg px-3 py-2 text-white
                         placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
              dir="rtl"
            />
          </div>

          {/* Muscle Groups */}
          <AutocompleteChips
            label="קבוצות שרירים"
            placeholder="הקלד או בחר קבוצת שרירים..."
            options={existingTags.muscleGroups}
            value={muscleGroups}
            onChange={setMuscleGroups}
          />

          {/* Equipment */}
          <AutocompleteChips
            label="ציוד נדרש"
            placeholder="הקלד או בחר ציוד..."
            options={existingTags.equipment}
            value={equipment}
            onChange={setEquipment}
          />

          {/* Remove Audio Toggle */}
          <div className="flex items-center justify-between py-2">
            <div className="flex items-center gap-2">
              {removeAudio ? (
                <VolumeX className="w-5 h-5 text-gray-400" />
              ) : (
                <Volume2 className="w-5 h-5 text-gray-400" />
              )}
              <span className="text-gray-300">הסר אודיו</span>
            </div>
            <button
              type="button"
              onClick={() => setRemoveAudio(!removeAudio)}
              className={`relative w-11 h-6 rounded-full transition-colors ${
                removeAudio ? 'bg-blue-600' : 'bg-gray-700'
              }`}
            >
              <span
                className={`absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full transition-transform ${
                  removeAudio ? 'translate-x-5' : ''
                }`}
              />
            </button>
          </div>
        </div>

        {/* Footer Actions */}
        <div className="border-t border-gray-800 p-4 flex gap-3">
          <Button onClick={handleSave} className="flex-1">
            שמור
          </Button>
          {segment?.details && (
            <Button onClick={handleDelete} variant="destructive">
              מחק
            </Button>
          )}
        </div>
      </DrawerContent>
    </Drawer>
  );
}
```

2. Update EditorPage.tsx to include SegmentDrawer:

```tsx
import { SegmentDrawer } from '@/components/tagging/SegmentDrawer';

// At the end of the component, before closing div:
<SegmentDrawer />
```

3. Update Button component to support destructive variant if not already:
   - Check if Button.tsx has variant="destructive"
   - If not, add: `destructive: 'bg-red-600 text-white hover:bg-red-700'`

Key implementation details:
- Media Fragments (#t=start,end) for video preview auto-scoping
- key={previewUrl} forces video reload on segment change
- muted autoPlay for preview (browser allows muted autoplay)
- Delete button only shows if segment has existing details
- Form validates name is required before save
  </action>
  <verify>
    - `npm run build` passes
    - Clicking segment opens drawer from bottom
    - Video preview plays selected segment
    - Form fields work with autocomplete
    - Save updates segment details in store
    - Segment card shows checkmark after save
  </verify>
  <done>Complete tagging drawer with video preview and exercise form</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build verification:
   ```bash
   cd frontend && npm run build
   ```
   Expected: Build succeeds with no errors

2. Drawer interaction:
   - Click segment card -> drawer slides up from bottom
   - Swipe down or click X -> drawer closes
   - Click outside drawer -> drawer closes

3. Form functionality:
   - Enter exercise name
   - Type in muscle groups field -> see autocomplete suggestions
   - Select or type new muscle group -> chip appears
   - Click X on chip -> chip removed
   - Same for equipment field
   - Toggle audio removal switch

4. Save flow:
   - Fill in name (required)
   - Click Save -> drawer closes
   - Segment card shows green checkmark
   - Reopen drawer -> form populated with saved data

5. Delete flow:
   - Open drawer with saved details
   - Click Delete -> confirm dialog
   - Details cleared, checkmark removed
</verification>

<success_criteria>
- Drawer opens from bottom on segment tap
- Video preview shows selected segment with Media Fragments
- Exercise name input with validation (required)
- Muscle groups autocomplete with chips (keyboard + click)
- Equipment autocomplete with chips (keyboard + click)
- Audio removal toggle switch
- Save persists to store, shows checkmark on card
- Delete clears details with confirmation
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-timeline-editor/03-03-SUMMARY.md`
</output>
