---
phase: 05-pwa-migration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - frontend/vite.config.ts
  - frontend/src/sw.ts
  - frontend/src/lib/shareTarget.ts
  - frontend/src/App.tsx
  - frontend/src/pages/UploadPage.tsx
  - frontend/src/stores/uploadStore.ts
autonomous: true

must_haves:
  truths:
    - "User can share a video from gallery and have it open in the app for processing"
    - "Shared video appears in upload UI ready for processing"
    - "Error message shown if share fails"
  artifacts:
    - path: "frontend/vite.config.ts"
      provides: "Web Share Target manifest configuration"
      contains: "share_target"
    - path: "frontend/src/sw.ts"
      provides: "Service worker intercepts /share-receiver POST and stores video"
      contains: "share-receiver"
    - path: "frontend/src/lib/shareTarget.ts"
      provides: "IndexedDB helpers for shared video storage"
      contains: "storeSharedVideo"
    - path: "frontend/src/App.tsx"
      provides: "App checks for shared video on mount and triggers upload"
      contains: "shared"
  key_links:
    - from: "frontend/src/sw.ts"
      to: "frontend/src/lib/shareTarget.ts"
      via: "dynamic import for storeSharedVideo"
      pattern: "import.*shareTarget"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/lib/shareTarget.ts"
      via: "import getSharedVideo"
      pattern: "getSharedVideo"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/stores/uploadStore.ts"
      via: "sets shared file in upload store"
      pattern: "setSharedFile|useUploadStore"
---

<objective>
Implement Web Share Target API to receive videos shared from device gallery.

Purpose: Enable users to share a workout video from their phone's gallery directly to the app, bypassing the manual upload flow. This is a key mobile UX improvement.
Output: Share target manifest config, service worker POST handler, IndexedDB helpers, React integration.
</objective>

<execution_context>
@C:\Users\OmriS\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\OmriS\.claude\get-shit-done\templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-pwa-migration/05-RESEARCH.md
@.planning/phases/05-pwa-migration/05-01-SUMMARY.md
@frontend/vite.config.ts
@frontend/src/sw.ts
@frontend/src/App.tsx
@frontend/src/pages/UploadPage.tsx
@frontend/src/stores/uploadStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install idb library and create shareTarget helpers</name>
  <files>frontend/package.json, frontend/src/lib/shareTarget.ts</files>
  <action>
**Install idb library**:
```bash
cd frontend
npm install idb
```

**Create frontend/src/lib/shareTarget.ts**:

```typescript
import { openDB, DBSchema } from 'idb';

interface ShareTargetDB extends DBSchema {
  'shared-videos': {
    key: string;
    value: {
      id: string;
      file: File;
      timestamp: number;
    };
  };
}

const DB_NAME = 'workout-share-target';
const STORE_NAME = 'shared-videos';
const DB_VERSION = 1;

async function getDB() {
  return openDB<ShareTargetDB>(DB_NAME, DB_VERSION, {
    upgrade(db) {
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
      }
    },
  });
}

export async function storeSharedVideo(id: string, file: File): Promise<void> {
  const db = await getDB();
  await db.put(STORE_NAME, {
    id,
    file,
    timestamp: Date.now(),
  });
  db.close();
}

export async function getSharedVideo(id: string): Promise<File | null> {
  const db = await getDB();
  const entry = await db.get(STORE_NAME, id);
  db.close();
  return entry?.file || null;
}

export async function deleteSharedVideo(id: string): Promise<void> {
  const db = await getDB();
  await db.delete(STORE_NAME, id);
  db.close();
}

// Cleanup old shared videos (>1 hour old)
export async function cleanupOldSharedVideos(): Promise<void> {
  const db = await getDB();
  const allEntries = await db.getAll(STORE_NAME);
  const oneHourAgo = Date.now() - 60 * 60 * 1000;

  for (const entry of allEntries) {
    if (entry.timestamp < oneHourAgo) {
      await db.delete(STORE_NAME, entry.id);
    }
  }
  db.close();
}
```

This module provides:
- `storeSharedVideo`: Called by service worker to store received video
- `getSharedVideo`: Called by React app to retrieve stored video
- `deleteSharedVideo`: Called after processing to clean up
- `cleanupOldSharedVideos`: Garbage collection for failed shares
  </action>
  <verify>Run `npm run build` - no TypeScript errors. The shareTarget.ts file compiles successfully.</verify>
  <done>idb installed, shareTarget.ts with IndexedDB helpers created</done>
</task>

<task type="auto">
  <name>Task 2: Add share_target to manifest and update service worker</name>
  <files>frontend/vite.config.ts, frontend/src/sw.ts</files>
  <action>
**Update frontend/vite.config.ts** - Add share_target to manifest:

In the VitePWA manifest object, add:
```typescript
share_target: {
  action: '/share-receiver',
  method: 'POST',
  enctype: 'multipart/form-data',
  params: {
    files: [
      {
        name: 'video',
        accept: ['video/*']
      }
    ]
  }
}
```

**Update frontend/src/sw.ts** - Add POST handler for /share-receiver:

Add this handler BEFORE the precacheAndRoute call (fetch events need to be handled first):

```typescript
// Handle Web Share Target POST requests
self.addEventListener('fetch', (event: FetchEvent) => {
  const url = new URL(event.request.url);

  // Intercept /share-receiver POST
  if (event.request.method === 'POST' && url.pathname === '/share-receiver') {
    event.respondWith(
      (async () => {
        try {
          const formData = await event.request.formData();
          const videoFile = formData.get('video') as File;

          if (!videoFile) {
            // No video in share, redirect to home
            return Response.redirect('/?error=no-video', 303);
          }

          // Validate video file type
          if (!videoFile.type.startsWith('video/')) {
            return Response.redirect('/?error=invalid-type', 303);
          }

          // Store video in IndexedDB with timestamp ID
          const videoId = `shared-${Date.now()}`;

          // Dynamic import to keep SW bundle small
          const { storeSharedVideo } = await import('./lib/shareTarget');
          await storeSharedVideo(videoId, videoFile);

          // Redirect to app with video ID in query params
          // Use 303 See Other to prevent POST resubmission on refresh
          return Response.redirect(`/?shared=${videoId}`, 303);
        } catch (error) {
          console.error('[SW] Share receiver error:', error);
          return Response.redirect('/?error=share-failed', 303);
        }
      })()
    );
    return; // Prevent other handlers from processing this request
  }
});
```

IMPORTANT: The fetch event listener with POST handling must be registered BEFORE precacheAndRoute is called, otherwise Workbox may interfere.
  </action>
  <verify>Run `npm run build`. Check that manifest.webmanifest contains share_target. Check that sw.js contains "share-receiver" string.</verify>
  <done>share_target in manifest, service worker intercepts POST and stores video in IndexedDB</done>
</task>

<task type="auto">
  <name>Task 3: Update upload store and UploadPage to handle shared files</name>
  <files>frontend/src/stores/uploadStore.ts, frontend/src/pages/UploadPage.tsx</files>
  <action>
**Update frontend/src/stores/uploadStore.ts** - Add shared file handling:

1. Add to UploadState interface:
```typescript
sharedFile: File | null;
setSharedFile: (file: File | null) => void;
```

2. Add to initial state (after `result: null`):
```typescript
sharedFile: null,
```

3. Add action (after reset):
```typescript
setSharedFile: (file) => set({ sharedFile: file }),
```

4. Update reset action to also clear sharedFile:
```typescript
reset: () => set({
  file: null,
  status: 'idle',
  progress: 0,
  error: null,
  result: null,
  sharedFile: null,
}),
```

**Update frontend/src/pages/UploadPage.tsx** - Process shared file:

The existing UploadPage uses `setFile(file)` via `handleFileSelect` callback from DropZone. When a file is set, the UI shows file info and an "Upload" button. The user then clicks "Upload" which calls `handleUpload()`.

For shared files, replicate this flow:

1. Add `sharedFile` and `setSharedFile` to the destructured store values:
```typescript
const {
  file,
  sharedFile,        // ADD
  setSharedFile,     // ADD
  status,
  // ... rest unchanged
} = useUploadStore();
```

2. Add a useEffect AFTER the existing effects (after "Cleanup on unmount") that watches sharedFile:
```typescript
// Process shared file from Web Share Target
useEffect(() => {
  if (sharedFile && status === 'idle') {
    // Set the shared file as the current file (same as DropZone callback)
    setFile(sharedFile);
    // Clear sharedFile to prevent re-processing on re-renders
    setSharedFile(null);
  }
}, [sharedFile, status, setFile, setSharedFile]);
```

This approach:
- When sharedFile exists in store (set by App.tsx from IndexedDB), it gets set as `file`
- The UI then shows the file info with "Upload" button (same as manual drop)
- User clicks "Upload" to process (consistent UX - no auto-processing)
- sharedFile is cleared immediately to prevent duplicate processing
- Only processes when status is 'idle' to avoid interrupting ongoing uploads
  </action>
  <verify>TypeScript compiles. The upload store has sharedFile state and setSharedFile action. In browser: manually test by setting sharedFile in store - it should appear as selected file in UI.</verify>
  <done>Upload store has sharedFile/setSharedFile, UploadPage watches sharedFile and transfers it to file state for processing</done>
</task>

<task type="auto">
  <name>Task 4: Update App.tsx to detect and handle shared videos</name>
  <files>frontend/src/App.tsx</files>
  <action>
**Update frontend/src/App.tsx**:

1. Import dependencies:
```typescript
import { useEffect } from 'react';
import { useSearchParams, useNavigate } from 'react-router-dom';
import { getSharedVideo, deleteSharedVideo, cleanupOldSharedVideos } from '@/lib/shareTarget';
import { useUploadStore } from '@/stores/uploadStore';
```

2. Add shared video detection logic inside App component:
```typescript
const [searchParams, setSearchParams] = useSearchParams();
const navigate = useNavigate();
const setSharedFile = useUploadStore(state => state.setSharedFile);

useEffect(() => {
  // Cleanup old shared videos on app start
  cleanupOldSharedVideos().catch(console.error);

  const sharedVideoId = searchParams.get('shared');
  const error = searchParams.get('error');

  if (error) {
    // Handle share errors
    let errorMessage = 'שגיאה בשיתוף הקובץ';
    if (error === 'no-video') {
      errorMessage = 'לא התקבל קובץ וידאו';
    } else if (error === 'invalid-type') {
      errorMessage = 'סוג קובץ לא נתמך';
    }
    // Show error toast or alert
    alert(errorMessage);
    // Clear error from URL
    setSearchParams({});
    return;
  }

  if (sharedVideoId) {
    // Retrieve shared video from IndexedDB
    getSharedVideo(sharedVideoId)
      .then((file) => {
        if (file) {
          console.log('[App] Received shared video:', file.name, file.size);
          // Set in upload store
          setSharedFile(file);
          // Delete from IndexedDB (cleanup)
          deleteSharedVideo(sharedVideoId);
          // Clear query param and ensure we're on upload page
          setSearchParams({});
          navigate('/');
        } else {
          console.warn('[App] Shared video not found in IndexedDB');
          setSearchParams({});
        }
      })
      .catch((err) => {
        console.error('[App] Error retrieving shared video:', err);
        setSearchParams({});
      });
  }
}, [searchParams, setSearchParams, navigate, setSharedFile]);
```

The flow:
1. User shares video from gallery to app
2. Service worker intercepts POST, stores in IndexedDB, redirects to `/?shared=ID`
3. App.tsx detects `shared` query param, retrieves file from IndexedDB
4. Sets file in uploadStore, clears IndexedDB entry, navigates to upload page
5. UploadPage sees sharedFile and processes it

Error handling:
- `?error=no-video` - No video in share payload
- `?error=invalid-type` - Shared file is not a video
- `?error=share-failed` - Unknown error in service worker
  </action>
  <verify>Run `npm run dev`. Navigate to `/?shared=test` - should handle gracefully (file not found). Navigate to `/?error=no-video` - should show Hebrew error message.</verify>
  <done>App.tsx detects shared video ID, retrieves from IndexedDB, triggers upload flow</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Build succeeds**: `npm run build` completes without errors
2. **Manifest has share_target**: Check `dist/manifest.webmanifest` contains share_target object with action: '/share-receiver'
3. **Service worker handles POST**: Check `dist/sw.js` contains share-receiver handler code
4. **IndexedDB helpers work**: shareTarget.ts exports all required functions
5. **Error handling works**: Navigate to `/?error=no-video` shows Hebrew error

**Full E2E test** (requires installed PWA on Android device):
1. Build app: `npm run build`
2. Serve from Flask: `python server.py`
3. Install PWA on Android device
4. Share a video from gallery to "Workout Video Editor"
5. App opens, video appears ready for processing
</verification>

<success_criteria>
- Web Share Target configured in manifest with video/* accept
- Service worker intercepts /share-receiver POST requests
- Video stored in IndexedDB and passed to React app via query param
- App.tsx retrieves shared video and sets in upload store
- UploadPage processes shared file like a regular drop
- Error states show Hebrew messages
</success_criteria>

<output>
After completion, create `.planning/phases/05-pwa-migration/05-02-SUMMARY.md`
</output>
