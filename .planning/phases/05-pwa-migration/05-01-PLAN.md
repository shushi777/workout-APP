---
phase: 05-pwa-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/vite.config.ts
  - frontend/src/sw.ts
  - frontend/src/vite-env.d.ts
  - frontend/public/icons/icon-192.png
  - frontend/public/icons/icon-512.png
  - frontend/src/components/ui/UpdatePrompt.tsx
  - frontend/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can install the app to home screen on mobile device"
    - "App shell is cached for offline access"
    - "User sees update notification when new version is available"
  artifacts:
    - path: "frontend/vite.config.ts"
      provides: "VitePWA plugin configuration with injectManifest strategy"
      contains: "VitePWA"
    - path: "frontend/src/sw.ts"
      provides: "Custom service worker with Workbox precaching"
      contains: "precacheAndRoute"
    - path: "frontend/src/vite-env.d.ts"
      provides: "TypeScript declarations for vite-plugin-pwa"
      contains: "vite-plugin-pwa/react"
    - path: "frontend/src/components/ui/UpdatePrompt.tsx"
      provides: "Service worker update notification UI"
      contains: "useRegisterSW"
  key_links:
    - from: "frontend/vite.config.ts"
      to: "frontend/src/sw.ts"
      via: "injectManifest srcDir/filename config"
      pattern: "filename.*sw\\.ts"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/components/ui/UpdatePrompt.tsx"
      via: "component import and render"
      pattern: "UpdatePrompt"
---

<objective>
Configure vite-plugin-pwa with custom service worker for PWA installability and offline caching.

Purpose: Enable users to install the app to their home screen and access the app shell when offline. This is the foundation for PWA capabilities.
Output: PWA manifest, custom service worker with Workbox, update prompt component, app icons.
</objective>

<execution_context>
@C:\Users\OmriS\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\OmriS\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-pwa-migration/05-RESEARCH.md
@frontend/vite.config.ts
@frontend/src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install vite-plugin-pwa and Workbox dependencies</name>
  <files>frontend/package.json</files>
  <action>
Install the PWA dependencies:
```bash
cd frontend
npm install -D vite-plugin-pwa
npm install workbox-window workbox-core workbox-routing workbox-strategies workbox-precaching
```

The dependencies:
- `vite-plugin-pwa`: Vite build plugin for PWA support
- `workbox-window`: Service worker registration (provides useRegisterSW hook)
- `workbox-core`, `workbox-routing`, `workbox-strategies`, `workbox-precaching`: Workbox modules for custom SW
  </action>
  <verify>Run `npm list vite-plugin-pwa workbox-window` and confirm packages are installed</verify>
  <done>vite-plugin-pwa and all Workbox packages are in devDependencies/dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Configure VitePWA plugin with injectManifest strategy</name>
  <files>frontend/vite.config.ts, frontend/src/vite-env.d.ts</files>
  <action>
**Update vite.config.ts** to add VitePWA plugin:

1. Import VitePWA from 'vite-plugin-pwa'
2. Add VitePWA to plugins array with this configuration:
   - `strategies: 'injectManifest'` (required for custom SW with Share Target)
   - `srcDir: 'src'`
   - `filename: 'sw.ts'`
   - `registerType: 'autoUpdate'`
   - `injectRegister: 'auto'`
   - `manifest` object with:
     - `name: 'Workout Video Editor'`
     - `short_name: 'Workout App'`
     - `start_url: '/'`
     - `scope: '/'`
     - `display: 'standalone'`
     - `background_color: '#030712'` (matches gray-950)
     - `theme_color: '#667eea'` (purple accent)
     - `description: 'עורך וידאו לאימונים - חתוך וסמן תרגילים'`
     - `icons` array with 192x192 and 512x512 icons (purpose: 'any maskable')
     - `share_target` object (will be handled in Plan 05-02, include empty placeholder for now)
   - `workbox` object with:
     - `navigateFallback: '/'`
     - `navigateFallbackDenylist: [/^\/api/, /^\/share-receiver/, /^\/download/, /^\/process/, /^\/get-tags/]`
   - `devOptions` with:
     - `enabled: true`
     - `type: 'module'`
     - `navigateFallback: '/'`

**Create frontend/src/vite-env.d.ts** with TypeScript declarations:
```typescript
/// <reference types="vite/client" />
/// <reference types="vite-plugin-pwa/react" />
/// <reference types="vite-plugin-pwa/client" />
```

NOTE: Do NOT add share_target to manifest yet - that will be done in Plan 05-02. Just configure the base PWA setup.
  </action>
  <verify>Run `npm run build` and confirm no TypeScript errors. Check that manifest.webmanifest is generated in dist/</verify>
  <done>VitePWA plugin configured with injectManifest strategy, TypeScript types declared</done>
</task>

<task type="auto">
  <name>Task 3: Create custom service worker with Workbox precaching</name>
  <files>frontend/src/sw.ts, frontend/public/icons/icon-192.png, frontend/public/icons/icon-512.png</files>
  <action>
**Create frontend/src/sw.ts**:

```typescript
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';

declare let self: ServiceWorkerGlobalScope;

// Precache app shell (generated by Vite PWA)
precacheAndRoute(self.__WB_MANIFEST);

// API calls: Network first, fallback to cache if offline
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/') ||
               url.pathname.startsWith('/process') ||
               url.pathname.startsWith('/get-tags'),
  new NetworkFirst({
    cacheName: 'api-cache',
    networkTimeoutSeconds: 10,
  })
);

// Video downloads: Network first (videos are large, don't cache aggressively)
registerRoute(
  ({ url }) => url.pathname.startsWith('/download/'),
  new NetworkFirst({
    cacheName: 'video-cache',
    networkTimeoutSeconds: 30,
  })
);

// Images: Cache first for performance
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
  })
);

// Fonts: Stale while revalidate
registerRoute(
  ({ request }) => request.destination === 'font',
  new StaleWhileRevalidate({
    cacheName: 'fonts-cache',
  })
);
```

**Create PWA icons**:
Create placeholder icons (simple colored squares for now):
- `frontend/public/icons/icon-192.png` - 192x192 purple square with white "W" text
- `frontend/public/icons/icon-512.png` - 512x512 purple square with white "W" text

Use a simple approach: Create the icons directory and add placeholder PNG files. The icons should be purple (#667eea) backgrounds. For simplicity, you can create these as base64-encoded PNGs or use a simple canvas-based generator script.

Alternatively, copy any existing icon and note that the user should replace them with proper app icons.
  </action>
  <verify>Run `npm run build` and confirm sw.js is generated in dist/. Check that icons exist in public/icons/</verify>
  <done>Custom service worker with Workbox precaching created, placeholder icons in place</done>
</task>

<task type="auto">
  <name>Task 4: Create UpdatePrompt component and add to App</name>
  <files>frontend/src/components/ui/UpdatePrompt.tsx, frontend/src/App.tsx</files>
  <action>
**Create frontend/src/components/ui/UpdatePrompt.tsx**:

```typescript
import { useRegisterSW } from 'virtual:pwa-register/react';

export function UpdatePrompt() {
  const {
    offlineReady: [offlineReady, setOfflineReady],
    needRefresh: [needRefresh, setNeedRefresh],
    updateServiceWorker,
  } = useRegisterSW({
    onRegistered(r) {
      // Check for updates every hour
      if (r) {
        setInterval(() => {
          r.update();
        }, 60 * 60 * 1000);
      }
    },
    onRegisterError(error) {
      console.error('SW registration error:', error);
    },
  });

  const close = () => {
    setOfflineReady(false);
    setNeedRefresh(false);
  };

  if (!offlineReady && !needRefresh) return null;

  return (
    <div className="fixed bottom-20 left-4 right-4 z-50 rounded-lg bg-gray-800 p-4 shadow-lg border border-gray-700">
      <div className="flex flex-col gap-2">
        <p className="text-sm text-gray-100">
          {offlineReady
            ? 'האפליקציה מוכנה לשימוש אופליין'
            : 'גרסה חדשה זמינה - לחץ לעדכון'}
        </p>
        <div className="flex gap-2 justify-end">
          {needRefresh && (
            <button
              className="px-4 py-2 min-h-[44px] bg-purple-600 text-white rounded-lg font-medium"
              onClick={() => updateServiceWorker(true)}
            >
              עדכן עכשיו
            </button>
          )}
          <button
            className="px-4 py-2 min-h-[44px] border border-gray-600 text-gray-100 rounded-lg"
            onClick={close}
          >
            סגור
          </button>
        </div>
      </div>
    </div>
  );
}
```

**Update frontend/src/App.tsx** to include UpdatePrompt:

1. Import UpdatePrompt from '@/components/ui/UpdatePrompt'
2. Add `<UpdatePrompt />` inside the main div, before or after `<BottomNav />`

The component appears above the bottom nav (bottom-20 = 80px from bottom, nav is 72px).
  </action>
  <verify>Run `npm run dev`, open browser DevTools > Application > Service Workers. Confirm SW registers. Check console for "SW registration" logs.</verify>
  <done>UpdatePrompt component renders, useRegisterSW hook registers service worker</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Build succeeds**: `npm run build` completes without errors
2. **Manifest generated**: Check `dist/manifest.webmanifest` exists with correct app info
3. **Service worker generated**: Check `dist/sw.js` exists with Workbox code
4. **Icons present**: Check `dist/icons/icon-192.png` and `dist/icons/icon-512.png` exist
5. **Dev mode works**: `npm run dev` starts without errors, SW registers in DevTools
6. **Installability**: In Chrome DevTools > Application, the "Install" section shows the app is installable (after building and serving from Flask)
</verification>

<success_criteria>
- VitePWA plugin configured with injectManifest strategy
- Custom service worker with Workbox caching strategies
- PWA manifest with app name, icons, colors
- UpdatePrompt component shows offline ready / update available
- App is installable when served from production build
</success_criteria>

<output>
After completion, create `.planning/phases/05-pwa-migration/05-01-SUMMARY.md`
</output>
